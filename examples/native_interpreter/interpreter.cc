#include <Python.h>
#include <iostream>
#include <paddle/extension.h>
#include <string>
#include <vector>

using InstructionType =
    std::tuple<std::string /*op*/, std::vector<std::string> /*inputs*/,
               std::string /*output*/>;

std::vector<std::string> input_names_;
std::vector<InstructionType> instructions_;

void print_tensor(const paddle::Tensor &tensor) {
  std::cout << "Tensor(";
  std::cout << tensor.place() << ", " << tensor.dtype() << ")[";
  auto *tensor_data = tensor.data<float>();
  for (size_t i = 0; i < tensor.numel(); ++i) {
    if (i == tensor.numel() - 1) {
      std::cout << tensor_data[i] << "]" << std::endl;
      break;
    }
    std::cout << tensor_data[i] << " ";
  }
}

static PyObject *interprete_py(PyObject *self, PyObject *args) {
  std::cout << "Hello from C++" << std::endl;
  return Py_None;
}

// parsing args codes are generated by ChatGPT
static PyObject *set_instructions_py(PyObject *self, PyObject *args) {
  PyObject *outer_list;
  Py_ssize_t outer_list_size;
  Py_ssize_t i, j;

  // Parse the arguments - a single list object
  if (!PyArg_ParseTuple(args, "O!", &PyList_Type, &outer_list)) {
    return NULL;
  }

  // Get the size of the outer list
  outer_list_size = PyList_Size(outer_list);

  // Loop over the outer list and print each inner list
  for (i = 0; i < outer_list_size; i++) {
    PyObject *inner_list = PyList_GetItem(outer_list, i);
    if (PyList_Check(inner_list)) {
      std::string op, l_operand, r_operand, result;
      std::vector<std::reference_wrapper<std::string>> instr_vec = {
          op, l_operand, r_operand, result};

      Py_ssize_t inner_list_size = PyList_Size(inner_list);
      // Loop over the inner list and print each string element
      for (j = 0; j < inner_list_size; j++) {
        PyObject *item = PyList_GetItem(inner_list, j);
        if (PyUnicode_Check(item)) {
          const char *str = PyUnicode_AsUTF8(item);
          instr_vec[j].get() = str;
        } else {
          std::stringstream err;
          err << "the element is not a string";
          throw std::runtime_error(err.str());
        }
      }
      instructions_.push_back(
          InstructionType(op, {l_operand, r_operand}, result));
    } else {
      std::stringstream err;
      err << "the element is not a list";
      throw std::runtime_error(err.str());
    }
  }

  return Py_None;
}

// parsing args codes are generated by ChatGPT
static PyObject *set_input_names_py(PyObject *self, PyObject *args) {
  PyObject *list;
  Py_ssize_t list_size;
  Py_ssize_t i;

  // Parse the arguments - a single list object
  if (!PyArg_ParseTuple(args, "O!", &PyList_Type, &list)) {
    return NULL;
  }

  // Get the size of the list
  list_size = PyList_Size(list);

  // Loop over the list and print each string element
  for (i = 0; i < list_size; i++) {
    PyObject *item = PyList_GetItem(list, i);
    if (PyUnicode_Check(item)) {
      const char *str = PyUnicode_AsUTF8(item);
      printf("get input_name : %s\n", str);
      input_names_.push_back(str);
    } else {
      std::stringstream err;
      err << "the element is not a string";
      throw std::runtime_error(err.str());
    }
  }
  return Py_None;
}

// TODO: make it real!!!
// pass in list of paddle::Tensor, and return a paddle::Tensor
static PyObject *execute_py(PyObject *self, PyObject *args) {
  int input_a, input_b;

  if (!PyArg_ParseTuple(args, "ii", &input_a, &input_b)) {
    return NULL;
  }

  auto a = paddle::full({3, 4}, input_a);
  auto b = paddle::full({3, 4}, input_b);

  for (InstructionType &instr : instructions_) {
    std::cout << "instruction: " << std::get<0>(instr) << ", "
              << std::get<1>(instr)[0] << ", " << std::get<1>(instr)[1] << ", "
              << std::get<2>(instr) << std::endl;
  }

  std::unordered_map<std::string, paddle::Tensor> environment;

  if (input_names_.size() != 2) {
    std::stringstream err;
    err << "inputs should be exactly equal to 2!";
    throw std::runtime_error(err.str());
  }
  // setup inputs
  environment[input_names_[0]] = a;
  environment[input_names_[1]] = b;

  // the execution loop
  for (InstructionType &instr : instructions_) {
    std::cout << "running instruction: " << std::get<0>(instr) << std::endl;
    // Retrieve all input values for this op
    std::vector<paddle::Tensor> inputs;
    for (const auto &input_name : std::get<1>(instr)) {
      if (environment.find(input_name) != environment.end()) {
        inputs.push_back(environment.at(input_name));
      } else {
        std::stringstream err;
        err << "Instruction referenced unknown value " << input_name << "!";
        throw std::runtime_error(err.str());
      }
    }

    // Run the specified operation
    paddle::Tensor result;
    const auto &op = std::get<0>(instr);
    if (op == "add") {
      if (inputs.size() != 2) {
        throw std::runtime_error("Unexpected number of inputs for add op!");
      }
      result = paddle::add(inputs[0], inputs[1]);
    } else if (op == "mul") {
      if (inputs.size() != 2) {
        throw std::runtime_error("Unexpected number of inputs for mul op!");
      }
      result = paddle::multiply(inputs[0], inputs[1]);
    } else {
      std::stringstream err;
      err << "Unknown operator " << op << "!";
      throw std::runtime_error(err.str());
    }
    print_tensor(result);

    // Write back result into environment
    const auto &output_name = std::get<2>(instr);
    environment[output_name] = std::move(result);
  }

  return Py_None;
}

static PyMethodDef _methods[] = {
    {"interprete", interprete_py, METH_VARARGS, NULL},
    {"execute", execute_py, METH_VARARGS, NULL},
    {"set_input_names", set_input_names_py, METH_VARARGS, NULL},
    {"set_instructions", set_instructions_py, METH_VARARGS, NULL},

    {NULL, NULL, 0, NULL}};

static struct PyModuleDef _module = {
    PyModuleDef_HEAD_INIT, "myinterpreter",
    "Module to demostrate a native interpreter", -1, _methods};

PyMODINIT_FUNC PyInit_myinterpreter(void) { return PyModule_Create(&_module); }
